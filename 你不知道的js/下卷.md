<!--
 * @Author: yushennan yousmellnice@foxmail.com
 * @Date: 2022-09-30 19:35:38
 * @LastEditors: yushennan yousmellnice@foxmail.com
 * @LastEditTime: 2022-10-06 15:43:37
 * @FilePath: /js/你不知道的js/下卷.md
 * @Description: 
 * 
-->
## 前言

Js 这门语言有些复杂的概念隐藏得很深，却以一种看似简单的形式呈现。例如，将函数作为回调函数传递，让JS 开发人员往往满足于使用这种现成遍历的机制，而不愿意去探索其中的原理。

**所以前端人员尝尝满足于一知半解，不愿深入地了解其深层原因和运作方式，这本书解决的正式这个问题。**

## 第一部分 类型和语法

### 第一章 类型

#### 1.1 类型

几乎所有的JS程序都会涉及某种形式的强制类型转换，处理这些情况时，需要有充分的把握和自信。

强类型转换时JS 开发人员最头疼的问题之一，它尝尝被诟病为语言设计上的一个缺陷，太危险，应该束之高阁。

#### 1.2 内置类型

JS 有七种内置类型：

- 空值 null
- 未定义 undefined
- 布尔值 boolean
- 数组 number
- 数字 number
- 字符串 string
- 对象 object
- 符号 symbol

``` js
  typeof null === 'object' // true
```

正确的返回结果，应该是 null ，但是这个 bug 由来已久，在 JS 中已经存在了将近二十年，也许永远也不会修复，因为牵涉到太多 WEB 系统，修复它会产生更多的 bug ，另许多系统无法正常工作

#### 1.3 值和类型

JS 的变量 是没有类型的，只有值才有。换个角度来说就是，JS 不做“类型强制”，可以随时随地的改变初始值的类型。

##### 1.3.1 underfined 和 underfined

### 第二章 值

数组（array）、字符串（string）和数字（number）是一个程序最基本的组成部分，但在JavaScript 中，它们可谓让人喜忧掺半。

#### 2.1 数组

和其他强类型语言不同，在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组就是通过这种方式来实现的）：

**delete 运算符可以将单元从数组中删除，但是，单元删除后，数组的 length 属性不会发生变化**

##### 类数组

有时需要将类数组转换成为真正的数组，这一般通过数组工具函数 indexOf cancat forEach 来实现，比如说 DOM 查询后会返回 DOM 元素列表，它们并非是真正意义上的数组， 一般通过 Array.prototype.slice.call(xx) 进行转换； Array.from(..) 也可以实现；

#### 2.2 字符串

字符串和数组的确很相似，它们都是类数组，都有 length 属性以及 indexOf(..)（从 ES5 开始数组支持此方法）和 concat(..) 方法

另外，数组有一个字符串没有的可变更成员函数 reverse()

#### 2.3 数字

暂时略

### 第三章 原生函数

常用的原生函数有：
• String()
• Number()
• Boolean()
• Array()
• Object()
• Function()
• RegExp()
• Date()
• Error()
• Symbol()——ES6 中新加入的！

再次强调，new String("abc") 创建的是字符串 "abc" 的封装对象，而非基本类型值 "abc"。

#### 3.1 内部属性 [[Class]]

所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 

Object.prototype.toString(..) 来查看。

也就是我们平时用来判断准确类型的方法之一；

#### 3.2 封装对象包装

基本数据类型值没有 .length 和 .toString 这样的属性和方法，需要通过封装对象才能访问，此时 JS 会自动为基本数据类型包装 封装一个对象；

#### 3.3 拆封

如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数。

#### 3.4 原生函数作为构造函数

关于数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常量的形式来创建它们。

如前所述，应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的结果。

##### 3.4.1 Array()

``` js
const array1 = new Array(1, 2, 3)
const array2 = [1, 2, 3]
```
Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。

所以这并非是明智之举，一是容易忘记，而是容易出错。而且这样创建出来的是一个空数组。

而且，在不同的浏览器控制台，显示的结果页不尽相同，这让问题变得更加复杂。

##### 3.4.2 Object(..)、Function(..) 和 RegExp(..)

除非万不得已，否则尽量不要使用 Object() Function() RegExp()

在实际情况中没有必要使用 new Object() 来创建对象，因为这样就无法像常量形式那样一次设定多个属性，且必须逐一设定。

构造函数 Function 只在极少数情况下很有用， 比如动态定义函数和函数体的时候。

不要把 Function 当做 eval 的替代品，基本上不会用这种方式来定义函数。

强烈建议使用常量形式，如 `/^a*b+/g/` 来进行正则表达式，不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它进行预编译和缓存。与前面构造函数不同， 

RegExp 有时还是有用的，比如动态定义正则表达式。

### 第四章 强制类型转换

如第一章所述，关于**强制类型转换** 是一个设计上的缺陷还是有用的特性，这一争论从 JS 诞生之日就开始了。

#### 4.1 值类型转换

将值从一种类型转换为另一种类型，通常称为类型转换，这是显式的情况；隐式的情况称为强制类型转换。

然而在 JS 中通常统称为强制类型转换，作者倾向于 “隐式强制类型转换” 和 “显式强制类型转换” 来区分。

``` js
const a = 42
const b = a + '' // 隐式强制类型转换
const c = String(a) // 显示强制类型转换
```

以上两者都是转换为字符串，但是不同的处理方式却成为了争论的焦点。

#### 4.2 抽象值操作

在介绍隐式和显式转换的区别之前，需要掌握字符串、数字和布尔值之间类型转换的基本规则。 

ES5 规范中定义了

##### 4.2.1 ToString

规范的 9.8 节中定义了抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。

数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后，再用“,”连接起来

###### JSON 字符串化 

工具函数 JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString。

所有安全的值都可以使用JSON值字符串化，安全的JSON值是指能够呈现为有效的 JSON 格式的值。

不安全的值有： `undefined / function / symbol` 还有循环引用的对象

JSON.stringify(..) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。

**JSON.stringify() 可以传递一个可选参数 replacer 它可以是数组或者函数，用来指定对象序列化过程中有哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像**

**JSON.stringify 还有一个可选参数 space ，用来指定输出的缩进格式，space 为正整数时，是指定每一级缩进的字符数，它还可以是字符串，此时最前面的是个字符被用于每一级的缩进**

JSON.stringify(..) 并不是强制类型转换。在这里介绍是因为它涉及 ToString 强制类型转换，具体表现在以下两点。

(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。
(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。


##### 4.2.2 toNumber

有时候需要将非数字当做数字用，

``` js
true -> 1
false -> 0
undefined -> NaN
null -> 0
```
ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。

##### 4.2.3 toBoolean

1. 假值

ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。

- underfined
- null
- false
- ""
- +0 -0 NaN

**从逻辑上来说，列表以外的都应该是真值。但是但是，JS 规范并没有给出明确的定义，只是给出了一些示例，例如规定所有的对象都是真值，我们可以理解为假值列表以外的值都是真值。**

2. 假值对象

这个标题似乎有点自相矛盾？前面说得 所有的对象都是真值，怎么还是有假值对象呢？

``` js 
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );
```

毫无疑问，上面的都是 true，浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来（exotic）值，这些就是“假值对象”。

3. 真值（truthy value）

**真值就是假值列表之外的值。**

``` js
var a = []; // 空数组——是真值还是假值？
var b = {}; // 空对象——是真值还是假值？
var c = function(){}; // 空函数——是真值还是假值？
var d = Boolean( a && b && c );
d -> true
```

#### 4.3 显示强制类型转换

显式强制类型转换是那些显而易见的类型转换，很多类型转换都属于此列。

我们在编码时应尽可能地将类型转换表达清楚，以免给别人留坑。

##### 4.3.1 字符串和数字之间的显式转换

``` js
var a = 42;
var b = String( a );
var c = "3.14";
var d = Number( c );
b; // "42"
d; // 3.14
```


##### 4.3.2 显式解析数字字符串

##### 4.3.3 显式转换成布尔值

``` js
var a = "0";
var b = [];
var c = {};
var d = "";
var e = 0;
var f = null;
var g;
Boolean( a ); // true
Boolean( b ); // true
Boolean( c ); // true
Boolean( d ); // false
Boolean( e ); // false
Boolean( f ); // false
Boolean( g ); // false
```

和前面讲过的 + 类似，一元运算符 ! 显式地将值强制类型转换为布尔值。但是它同时还将真值反转为假值（或者将假值反转为真值）。
所以显式强制类型转换为布尔值最常用的方是  `!!`  , 因为第二个 `!` 会将结果反转回原值。

建议使用 Boolean(..) 和 !! 来进行显式转换以便让代码更清晰易读。

#### 4.4 隐式强制类型转换

隐式强制类型转换指的是那些隐蔽的强制类型转换，副作用也不是很明显。换句话说，你自己觉得不够明显的强制类型转换都可以算作隐式强制类型转换。

问题是，隐式强制类型转换真是如此不堪吗？它是不是 JavaScript 语言的设计缺陷？我们是否应该对其退避三舍？估计大多数读者会回答“是的”。其实不然，请容我细细道来。

我们需要从另一个角度去看待隐式强制类型转换，看看它究竟为何物、该如何使用，不要简单地当作“显示强制类型转换的对立面”， 因为这样理解过于狭隘，忽略了他们之间一个细微却十分重要的区别

##### 4.4.1 隐式地简化

##### 4.4.2 字符串和数字之间的隐式强制类型转换

##### 4.4.3

##### 4.4.4 隐式强制类型转换为布尔值

相对于布尔值，数字和字符串操作中的隐式强制类型转换还算比较明显。

主要有以下情况：

1. if (..) 语句中的判断表达式

2. for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。

3. while (..) 和 do..while(..) 循环中的条件判断表达式。

4. ? : 中的条件判断表达式。

5. 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。

##### 4.4.5 || 和 && 

作者认为，称他们为 “逻辑运算符” 不太准确，应该是 “选择器运算符” 或 “操作数选择器运算符” 更恰当。

为什么？因为 JS 中他们返回的不是布尔值。返回的是两个操作数中的其中一个（仅且一个）。

引述 ES5 规范 11.11 节： && 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。

``` js
var a = 42;
var b = null;
var c = "foo";
if (a && (b || c)) {
 console.log( "yep" );
}

// 实际上  a && (b || c)  的结果是 “foo” 而并非是 true ， 然后 if 将 foo 强制类型转换为布尔值，所以最后的结果是 true
```

##### 4.4.6 符号的强制类型转换

符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true）。

#### 4.5 宽松相等和严格相等

宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。
常见的误区是 *“== 检查值是否相等，=== 检查值和类型是否相等”*。听起来蛮有道理，然而
还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。
正确的解释是： **“== 允许在相等比较中进行强制类型转换，而 === 不允许。”**


##### 4.5.1 相等比较操作的性能

== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。

##### 4.5.2 抽象相等

当两个值的类型相同时，仅比较它们是否相等。例如 42 等于 42 ，‘abc’ 等于 ‘abc’

有几个非常规的情况需要注意：
- NaN 不等于 NaN 
- +0 等于 -0

=== 的定义和 11.9.3.1 一样，包括对象的情况。实际上在比较两个对象的时候，== 和 === 的工作原理是一样的。

11.9.3 节中还规定，== 在比较两个不同类型的值时会发生隐式强制类型转换，会将其中之一或两者都转换为相同的类型后再进行比较。

1. 字符串和数字之间的相等比较

ES5 规范 11.9.3.4-5 这样定义：
(1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。
(2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。

2. 其他类型和布尔类型之间的相等比较

(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；
(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。

3. null 和 undefined 之间的相等比较

(1) 如果 x 为 null，y 为 undefined，则结果为 true。
(2) 如果 x 为 undefined，y 为 null，则结果为 true。

在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他值都不存在这种情况。

4. 对象和非对象之间的相等比较

(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；
(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。

##### 4.5.3 比较少见的情况

我们已经全面介绍了 == 中的隐式强制类型转换（常规和非常规的情况），现在来看一下那些需要特别注意和避免的比较少见的情况。

首先来看看更改内置原生原型会导致哪些奇怪的结果。

1. 返回其他数字

2. 假值的相等比较

3. 极端情况

``` js
[] == ![] // true ，因为 [] == ![] 变成了 [] == false， false == [] 

2 == [2] // true  [2] 会强制类型转换成 字符串 2， 强制类型转换过程中数组会进行字符串化。

"" == [null] // true [null] 会直接转换为 ""，所以 "" == ""
```

4. 完整性检查

5. 安全运用隐式强制类型转换

- 如果两边的值中有 true 或者 false，千万不要使用 ==。
- 如果两边的值中有 []、"" 或者 0，尽量不要使用 ==。

这时最好用 === 来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。
**所以 == 和 === 选择哪一个取决于是否允许在相等比较中发生强制类型转换。**

#### 4.6 抽象关系比较

#### 4.7 小结

在处理强制类型转换的时候要十分小心，尤其是隐式强制类型转换。在编码的时候，要知其然，还要知其所以然，并努力让代码清晰易读。


### 第五章、语法

#### 5.1 语句和表达式

开发人员常常将“语句”（statement）和“表达式”（expression）混为一谈，但这里我们要
将二者区别开来，因为它们在 JavaScript 中存在一些重要差别。

##### 5.1.1 语句的结果值
 
##### 5.1.2 表达式的副作用

##### 5.1.3 上下文规则

1. 大括号

- 对象常量
- 标签





































